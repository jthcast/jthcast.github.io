{"version":3,"sources":["components/atoms/PrismCode/index.tsx","data/PostsData/4.tsx"],"names":["PrismCode","code","language","plugins","ref","useRef","useEffect","current","Prism","highlightElement","className","join","trim","Item","target","rel","href","src","aria-label","alt"],"mappings":"+LA6CeA,IA1BG,SAAC,GAIa,IAH9BC,EAG6B,EAH7BA,KAG6B,IAF7BC,gBAE6B,MAFlB,aAEkB,EAD7BC,EAC6B,EAD7BA,QAEMC,EAAMC,iBAAoB,MAOhC,OALAC,qBAAU,WACJF,EAAIG,SACNC,IAAMC,iBAAiBL,EAAIG,WAE5B,IAED,qBAAKG,UAAWP,GAAWA,EAAQQ,KAAK,KAAxC,SACE,sBACEP,IAAKA,EACLM,UAAS,mBAAcR,GAAd,OACPC,EAAO,WAAOA,EAAQQ,KAAK,MAAS,IAHxC,SAMGV,GAAQA,EAAKW,a,wFCiHPC,UApJF,WA2CX,OACE,qCACE,gDACA,0kBAKA,sdAKA,oQAIA,4BACE,mBACEC,OAAO,SACPC,IAAI,aACJC,KAAK,oDACLN,UAAU,oBAJZ,2DASF,0FACA,2OAEO,IACL,sBAAMA,UAAU,WAAhB,+KAIF,2NAIA,oOAIA,kRAIA,6NAIA,uPAIA,wNAGA,4BACE,mBACEI,OAAO,SACPC,IAAI,aACJC,KAAK,mFACLN,UAAU,oBAJZ,yDASF,mCACE,qBACEO,IAAI,2HACJC,aAAW,mBACXC,IAAI,qBAEN,sKAEF,qFACA,8gBAMA,cAAC,IAAD,CAAWlB,KA7HgB,89BA8H3B,+QAIA,mPAIA,0GACoC,IAClC,sBAAMS,UAAU,WAAhB,0IAFF","file":"static/js/8.a6cb07b4.chunk.js","sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport Prism from 'prismjs';\nimport 'prismjs/components/prism-css-extras';\nimport 'prismjs/components/prism-scss';\nimport 'prismjs/components/prism-typescript';\n// import 'prismjs/components/prism-jsx';\n// import 'prismjs/components/prism-tsx';\n// import 'prismjs/plugins/line-numbers/prism-line-numbers';\n// import 'prismjs/plugins/line-numbers/prism-line-numbers.css';\nimport 'prismjs/themes/prism-tomorrow.css';\n// import './prism-vsc-dark-plus.scss';\nimport './PrismCode.scss';\n\ninterface IPrismCode {\n  code?: string;\n  language?: string;\n  plugins?: Array<string>;\n}\n\nconst PrismCode = ({\n  code,\n  language = 'typescript',\n  plugins,\n}: IPrismCode): JSX.Element => {\n  const ref = useRef<HTMLElement>(null);\n\n  useEffect(() => {\n    if (ref.current) {\n      Prism.highlightElement(ref.current);\n    }\n  }, []);\n  return (\n    <pre className={plugins && plugins.join(' ')}>\n      <code\n        ref={ref}\n        className={`language-${language}${\n          plugins ? ` ${plugins.join(' ')}` : ''\n        }`}\n      >\n        {code && code.trim()}\n      </code>\n    </pre>\n  );\n};\n\nexport default PrismCode;\n","import React from 'react';\nimport PrismCode from '../../components/atoms/PrismCode';\n// import reactLifeCycle from '../../resources/images/post/4/react life cycle.jpeg';\n\nconst Item = (): JSX.Element => {\n  const checkSystemPreferenceCode = `\nimport React, { ErrorInfo, ReactNode } from 'react';\nimport ErrorPage from '../../pages/ErrorPage';\n\ninterface Props {\n  children: ReactNode;\n}\n\ninterface ErrorBoundaryInterface {\n  hasError: boolean;\n  error?: Error | null;\n  errorInfo?: ErrorInfo;\n}\n\nclass ErrorBoundary extends React.Component<Props, ErrorBoundaryInterface> {\n  constructor(props: Props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryInterface {\n    return { hasError: true, error };\n  }\n\n  // componentDidCatch(error: Error, errorInfo: ErrorInfo): void {\n  //   logErrorToMyService(error, errorInfo);\n  //   console.error('Uncaught error:', error, errorInfo);\n  // }\n\n  render(): JSX.Element | ReactNode {\n    const { hasError } = this.state;\n    if (hasError) {\n      return <ErrorPage />;\n    }\n\n    const { children } = this.props;\n    return children;\n  }\n}\n\nexport default ErrorBoundary;\n`;\n  return (\n    <>\n      <h2>Error boundary</h2>\n      <p>\n        우리가 React를 사용하는 이유는 상태의 변화로 컴포넌트를 제어하기 쉽기\n        때문이다. 이러한 컴포넌트 하나하나가 모여 하나의 웹 사이트를 구성하게\n        된다. 그런데, 쌓아 올린 컴포넌트 중 어느 한 군데서 에러가 발생한다면?\n      </p>\n      <p>\n        React 또한 Javascript의 일부일 뿐.. 에러가 발생한 즉시 React는 모든\n        컴포넌트를 언마운트 하며 죽어버릴 것이다. 한곳에서 발생한 오류로\n        어플리케이션이 작동 중단돼서는 안 될 일이다.\n      </p>\n      <p>\n        그렇다면 try/catch처럼 오류를 제어할 순 없을까? 이러한 개념에서 Error\n        boundary가 지원되기 시작했다.\n      </p>\n      <p>\n        <a\n          target=\"_blank\"\n          rel=\"noreferrer\"\n          href=\"https://ko.reactjs.org/docs/error-boundaries.html\"\n          className=\"jth-external-link\"\n        >\n          에러 경계(Error Boundaries)\n        </a>\n      </p>\n      <h2>Class 형식이 필요한 이유</h2>\n      <p>\n        그래서, Class 형식이 필요한 이유가 무엇인가에 대해 간단히 설명하자면,\n        한마디로{' '}\n        <span className=\"jth-text\">\n          Hooks에서 지원하는 방식으로는 오류 발생 시 제어할 방법이 없다.\n        </span>\n      </p>\n      <p>\n        · getSnapshotBeforeUpdate: 가장 마지막으로 렌더링 된 결과가 DOM 등에\n        반영되었을 때 호출\n      </p>\n      <p>\n        · getDerivedStateFromError: 하위의 자손 컴포넌트에서 오류가 발생했을 때\n        render 단계에서 호출\n      </p>\n      <blockquote>\n        render 단계는 React가 DOM 갱신이 일어날 때 이전과 이후를 비교하며 변경\n        사항을 계산하는 단계이다.\n      </blockquote>\n      <p>\n        · componentDidCatch: 하위의 자손 컴포넌트에서 오류가 발생했을 때 commit\n        단계에서 호출\n      </p>\n      <blockquote>\n        commit 단계는 React가 비교를 끝내고 DOM에 직접적으로 갱신될 내용을\n        적용하는 단계이다.\n      </blockquote>\n      <p>\n        위의 세 가지 라이프 사이클이 아직은 Hooks에서 구현되지 않았기 때문이다.\n      </p>\n      <p>\n        <a\n          target=\"_blank\"\n          rel=\"noreferrer\"\n          href=\"https://reactjs.org/docs/hooks-faq.html#do-hooks-cover-all-use-cases-for-classes\"\n          className=\"jth-external-link\"\n        >\n          Do Hooks cover all use cases for classes?\n        </a>\n      </p>\n      <figure>\n        <img\n          src=\"https://cdn.jsdelivr.net/gh/jthcast/jthcast-client@master/src/resources/images/post/4/react%20life%20cycle.jpeg?raw=true\"\n          aria-label=\"React life cycle\"\n          alt=\"React life cycle\"\n        />\n        <figcaption>머리 아프지만, 알면 도움이 되는 라이프 사이클</figcaption>\n      </figure>\n      <h2>Errorboundary 컴포넌트 구현</h2>\n      <p>\n        결국 하위의 자손 컴포넌트에서 오류가 발생했을 때 무언가 조치하려면\n        Errorboundary를 getDerivedStateFromError, componentDidCatch의 단계에서\n        처리해야 하므로 Class 형식으로 만들어야 제대로 된 라이프 사이클에서\n        처리할 수 있다.\n      </p>\n      <PrismCode code={checkSystemPreferenceCode} />\n      <p>\n        getDerivedStateFromError 단계에서 에러를 확인, hasError의 상태를 true로\n        변경하고 ErrorPage를 렌더링 하도록 구성하였다.\n      </p>\n      <p>\n        만약 로깅 로직(Sentry 등)이 존재한다면 componentDidCatch 단계에서 로깅\n        서비스를 호출하면 된다.\n      </p>\n      <p>\n        Errorboundary는 try/catch처럼 트리 내에서{' '}\n        <span className=\"jth-text\">\n          하위에 존재하는 컴포넌트의 에러만을 포착한다\n        </span>\n        는 점을 잊지 말아야 한다. 그러므로 최상위에 하나를 배치하여 모두\n        처리할지, 혹은 에러가 날 가능성이 있는 컴포넌트마다 따로 감싸줄지는\n        사용자가 선택하면 된다.\n      </p>\n    </>\n  );\n};\n\nexport default Item;\n"],"sourceRoot":""}